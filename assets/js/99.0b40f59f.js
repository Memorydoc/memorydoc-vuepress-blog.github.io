(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{603:function(a,t,s){"use strict";s.r(t);var r=s(21),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"mysql-事务与锁机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-事务与锁机制"}},[a._v("#")]),a._v(" Mysql 事务与锁机制")]),a._v(" "),s("h2",{attrs:{id:"下面的脏读、不可重复读、幻读都是-模拟在a、b事务中进行的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#下面的脏读、不可重复读、幻读都是-模拟在a、b事务中进行的"}},[a._v("#")]),a._v(" 下面的脏读、不可重复读、幻读都是 模拟在A、B事务中进行的")]),a._v(" "),s("h2",{attrs:{id:"脏读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[a._v("#")]),a._v(" 脏读")]),a._v(" "),s("p",[a._v("A 事务 读取某一值的数据， B事务将该值修改了， A中会读取到")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/mysql/image-20200813210713283.png",alt:"image-20200813210713283"}})]),a._v(" "),s("h2",{attrs:{id:"不可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[a._v("#")]),a._v(" 不可重复读")]),a._v(" "),s("p",[a._v("A 事务中 读取某一值的数据，B事务中将该值修改了， 并且 执行了commit ， 那么A中会读取到 (针对于 update  和  delete 语句)")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/mysql/image-20200813210704429.png",alt:"image-20200813210704429"}})]),a._v(" "),s("h2",{attrs:{id:"幻读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[a._v("#")]),a._v(" 幻读")]),a._v(" "),s("p",[a._v("A事务中 查询某一条件中的所有数据，第一次查询出来 2条， B事务中在该命中条件下， 又插入了一条数据，那么A再次查询， 会查出来")]),a._v(" "),s("p",[a._v("3条数据，出现幻读（针对于insert语句）")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/mysql/image-20200813210649975.png",alt:"image-20200813210649975"}})]),a._v(" "),s("h2",{attrs:{id:"事务隔离级别总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别总结"}},[a._v("#")]),a._v(" 事务隔离级别总结")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/mysql/image-20200813210738819.png",alt:"image-20200813210738819"}})]),a._v(" "),s("blockquote",[s("p",[a._v("mysql 默认的事务隔离界别是 Repeatable Read 可重复读， 可以解决 上面 三大问题（InnoDB中可以解决）")])]),a._v(" "),s("h2",{attrs:{id:"mysql-innodb-事务隔离级别的支持程度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-innodb-事务隔离级别的支持程度"}},[a._v("#")]),a._v(" Mysql InnoDB 事务隔离级别的支持程度")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/mysql/image-20200813211042362.png",alt:"image-20200813211042362"}})]),a._v(" "),s("h2",{attrs:{id:"表锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[a._v("#")]),a._v(" 表锁")]),a._v(" "),s("p",[a._v("Lock share in mode")]),a._v(" "),s("h2",{attrs:{id:"排它锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排它锁"}},[a._v("#")]),a._v(" 排它锁")]),a._v(" "),s("p",[a._v("排他锁又称为写锁， 简称X锁")]),a._v(" "),s("p",[a._v("排它锁不能与其他锁并存， 如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁（共享锁、排他锁），只有该获取了排他锁的事务是可以对数据进行读取和修改的")]),a._v(" "),s("h3",{attrs:{id:"加锁方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加锁方式"}},[a._v("#")]),a._v(" 加锁方式：")]),a._v(" "),s("ul",[s("li",[a._v("自动： delete/update/insert 默认加上X锁")]),a._v(" "),s("li",[a._v("手动： select * from student where id = 1 for update;")]),a._v(" "),s("li",[a._v("释放锁： 事务结束")])]),a._v(" "),s("h2",{attrs:{id:"意向锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[a._v("#")]),a._v(" 意向锁")]),a._v(" "),s("p",[a._v("存储引擎自己维护的， 在加锁之前，先加一个意向锁，提高了效率")]),a._v(" "),s("h2",{attrs:{id:"锁的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁的作用"}},[a._v("#")]),a._v(" 锁的作用")]),a._v(" "),s("p",[a._v("数据安全")]),a._v(" "),s("h2",{attrs:{id:"锁锁住的是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁锁住的是什么"}},[a._v("#")]),a._v(" 锁锁住的是什么？")]),a._v(" "),s("p",[a._v("锁锁住的是索引")]),a._v(" "),s("h3",{attrs:{id:"锁种类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁种类"}},[a._v("#")]),a._v(" 锁种类")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Record Lock(精准命中的锁)")]),a._v(" "),s("blockquote",[s("p",[a._v("= 条件的时候")])])]),a._v(" "),s("li",[s("p",[a._v("Gap Lock  间隙锁")]),a._v(" "),s("blockquote",[s("p",[a._v("使用 > 或者 <  条件的时候， 是间隙锁")])])]),a._v(" "),s("li",[s("p",[a._v("临界锁")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);