(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{608:function(t,a,e){"use strict";e.r(a);var s=e(21),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"jvm优化实战"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm优化实战"}},[t._v("#")]),t._v(" JVM优化实战")]),t._v(" "),e("h2",{attrs:{id:"服务器配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器配置"}},[t._v("#")]),t._v(" 服务器配置")]),t._v(" "),e("ul",[e("li",[t._v("8 核心 16G")]),t._v(" "),e("li",[t._v("JDK1.8")])]),t._v(" "),e("h2",{attrs:{id:"jvm-核心参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm-核心参数"}},[t._v("#")]),t._v(" JVM 核心参数")]),t._v(" "),e("blockquote",[e("p",[t._v("因为是电商项目，需要使用并发垃圾回收器相关的参数，所以这里就不介绍非并发垃圾回收器的相关参数了，有需要请百度查询。")])]),t._v(" "),e("h3",{attrs:{id:"并行收集器相关参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并行收集器相关参数"}},[t._v("#")]),t._v(" 并行收集器相关参数")]),t._v(" "),e("p",[t._v("｜参数名称｜\t含义｜默认值｜｜\n｜-XX:+UseParallelGC ｜\tFull GC采用parallel MSC(此项待验证)\t｜选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)    ｜")]),t._v(" "),e("p",[t._v("｜-XX:+UseParNewGC\t｜设置年轻代为并行收集\t ｜\t可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 ｜")]),t._v(" "),e("p",[t._v("｜-XX:ParallelGCThreads｜\t并行收集器的线程数\t ｜\t此值最好配置与处理器数目相等 同样适用于CMS ｜\n｜-XX:+UseParallelOldGC\t｜年老代垃圾收集方式为并行收集(Parallel Compacting)\t \t｜这个是JAVA 6出现的参数选项｜\n｜-XX:MaxGCPauseMillis\t｜每次年轻代垃圾回收的最长时间(最大暂停时间)\t \t｜如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.｜\n｜-XX:+UseAdaptiveSizePolicy｜\t自动选择年轻代区大小和相应的Survivor区比例\t｜ \t设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. ｜\n｜-XX:GCTimeRatio\t｜设置垃圾回收时间占程序运行时间的百分比\t \t｜公式为1/(1+n) ｜\n｜-XX:+ScavengeBeforeFullGC\tFull GC前调用YGC\ttrue\t｜Do young generation GC prior to a full GC. (Introduced in 1.4.1.) ｜")]),t._v(" "),e("h4",{attrs:{id:"cms相关参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cms相关参数"}},[t._v("#")]),t._v(" CMS相关参数")]),t._v(" "),e("p",[t._v('｜-XX:+UseConcMarkSweepGC ｜\t使用CMS内存收集\t ｜\t测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.??? ｜\n｜-XX:+AggressiveHeap\t｜ \t \t｜试图是使用大量的物理内存 长时间大内存使用的优化，能检查计算资源（内存， 处理器数量） 至少需要256MB内存 大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）｜\n｜-XX:CMSFullGCsBeforeCompaction\t｜多少次后进行内存压缩\t \t｜由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生"碎片",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.｜\n｜-XX:+CMSParallelRemarkEnabled\t｜降低标记停顿\t \t ｜｜\n｜-XX+UseCMSCompactAtFullCollection\t｜ 在FULL GC的时候， 对年老代的压缩\t ｜\tCMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。 可能会影响性能,但是可以消除碎片｜\n｜-XX:+UseCMSInitiatingOccupancyOnly\t使用手动定义初始化定义开始CMS收集\t \t禁止hostspot自行触发CMS GC｜\n｜-XX:CMSInitiatingOccupancyFraction=70｜\t使用cms作为垃圾回收 使用70％后开始CMS收集｜\t92\t｜为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式｜\n｜-XX:CMSInitiatingPermOccupancyFraction\t设置Perm Gen使用到达多少比率时触发｜\t92\t ｜\n｜-XX:+CMSIncrementalMode\t设置为增量模式｜\t｜ \t用于单CPU情况｜\n｜-XX:+CMSClassUnloadingEnabled\t ｜｜｜')]),t._v(" "),e("h3",{attrs:{id:"未进行任何优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#未进行任何优化"}},[t._v("#")]),t._v(" 未进行任何优化")]),t._v(" "),e("p",[t._v("系统QPS 较低， 所能承受的并发较低")]),t._v(" "),e("p",[e("img",{attrs:{src:"youhua2",alt:"img.png"}})]),t._v(" "),e("h4",{attrs:{id:"jvm-参数如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm-参数如下"}},[t._v("#")]),t._v(" JVM 参数如下")]),t._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[t._v("-Xms1024m \n-Xmx1024m \n-XX:MaxMetaspaceSize"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("256m\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("可以看出默认所提供的 JVM 堆内存远远不足以维持系统的运行体量")]),t._v(" "),e("h3",{attrs:{id:"优化第一次"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化第一次"}},[t._v("#")]),t._v(" 优化第一次")])])}),[],!1,null,null,null);a.default=r.exports}}]);